// const app = require('./app')
// console.log(app.z());

// filter function

// const arr = [2,3,4,5,6];

// // arr.filter((item)=>{
// //     console.log(item)
// // })

// let result = arr.filter((item)=>{
//     return item === 3
// })
// console.log(result);
// /////////////////////////////////////////////////////////////////////////////////////////////
// Modules in node /////////////
// console.log, file systems , buffer , error , are some global modules which need not to be import
// const fs = require('fs');

// fs.writeFileSync("hello.txt", "Hey Aniket Welcome");
// console.log("------->", __dirname)

//////////////////////////////////////////////////////
// we can write any name instead of fs of const b

// const fs = require('fs').writeFileSync;
// fs("abs.txt","hey gamer");

///////////////////////////////////////////////////////////////////////
// Making a basic server
// here createServer is function as a parameter
// http module handles request and response from user



// const http = require('http');

//     http.createServer((request, response) => {
//         response.write("<h1>Hey Aniket here, Welcome to this page</h1>");
//         response.end();
//     }).listen(4500);

//////////////////////////////////////////////////////////////
// Package.json  file ////////////////////
// it keeps details of our project - which ncommands
// if package.json file is deleted then our project will be destoryed - because it is v imp
// no need to push node_modules package on git - put it into .gitignore file
// if node_modules package is deleted then it can again generated by npm install





// using colors package
// const colors = require('colors');
// console.log("Helloe".bgCyan)

// const chalk = require('chalk');

// console.log("chalk".bgBlue)

// Nodemon //////////////////////////^^^^^^^^^^^^^^^^^^^^^^^^
// it runs project every time continously so  no need to do node index.js again and again
// just do nodemon index.js one time and it will run project continously
// we can save alot of time using this

// console.log("rry suhbd");
// console.log("Aniket sdhjb fchjsdzb");


// node js is async but it is single threaded


//////////////////////////// ^^^^^^^^^^^^^^^^^^^^^^
// Making a simple APi

// -Make a simple server
// -create header and api body
// -create an API with static data
// -put data into another file
// here below 500 is type of error

// const http = require('http');
// const data  = require('./data')

// http.createServer((request, response)=>{
// response.writeHead(500, {'Content-Type':'application\json'});
//     response.write(JSON.stringify(data));
//     response.end();
// }).listen(5000);

//////////////////////////////////////////////////////////
// Getting input from command line
// argv   = argument vector
// type   node index.js hello third uasgfusgba bsujdf        in terminal

// console.log(process.argv[2])

// for creating filr
// const fs = require('fs')

// const input = process.argv;
// fs.writeFileSync(input[2], input[3])


// for removing and adding


// const fs = require('fs')

// const input = process.argv;

// if (input[2] == 'add') {
//     fs.writeFileSync(input[3], input[4])
// }
// else if(input[2] == 'remove'){
//     fs.unlinkSync(input[3]);
// }
// else{
//     console.log("Invalid Output")
// }

// ^^^^^^^^^^^^^  CURD Operations

// const fs = require('fs');

// const path = require('path');

// const dirPath = path.join(__dirname, 'crud')

// const filePath = `${dirPath}/apple.txt`;

// fs.writeFileSync(filePath, 'This is apple from apple file')

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
// synchronous vs asynchronous
// in synchronous if there are 3 file and file 1 require 4 mins and file 2 require 4 mins
// and file 3 requires 1 mins then first it will load file 1 then file 2 then file 3

// but in asynchronous it will not stop for any big file here it will load file 3 first

// console.log("start execution"); // 1

// setTimeout(() => {
//     console.log("logic execution"); // 2
// },2000)

// console.log("complete exe....."); // 3

// another exaple  (drawback)

// let a = 10;
// let b = 0;

// setTimeout(()=>{
//     b = 20;
// }, 2000)

// console.log(a+b);
// // value will be 10 because b = 20 will take more time and here comes a disadvantage of this

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////
// Handling asynchronous data
// above disadvantage can be handle by using promises

let a = 20;
let b = 0;


let waitingData = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(30)
    }, 2000)
})

waitingData.then((data) => {
    console.log(a + data);
})


